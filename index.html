<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>RoyMan Draw</title>
<meta name="description" content="An infinite drawing canvas â€” draw anywhere, zoom & pan freely.">
<meta name="theme-color" content="#000000">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="RoyMan Draw">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-192.png">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; width: 100vw; height: 100vh; cursor: crosshair; font-family: 'Courier New', monospace; }
  #canvas { position: absolute; top: 0; left: 0; }

  #ui {
    position: fixed;
    bottom: 28px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.12);
    backdrop-filter: blur(12px);
    padding: 8px 14px;
    border-radius: 40px;
    z-index: 100;
    user-select: none;
    white-space: nowrap;
    max-width: calc(100vw - 32px);
    overflow-x: auto;
  }

  .tool-btn {
    background: none;
    border: none;
    color: rgba(255,255,255,0.6);
    width: 36px;
    height: 36px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 15px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
    flex-shrink: 0;
  }
  .tool-btn:hover { background: rgba(255,255,255,0.1); color: #fff; border-color: rgba(255,255,255,0.4); }
  .tool-btn.active { background: #fff; color: #000; border-color: #fff; }
  .tool-btn:disabled { opacity: 0.2; cursor: default; }
  .tool-btn:disabled:hover { background: none; color: rgba(255,255,255,0.6); border-color: rgba(255,255,255,0.2); }

  .divider { width: 1px; height: 24px; background: rgba(255,255,255,0.15); flex-shrink: 0; }

  #size-slider {
    -webkit-appearance: none;
    appearance: none;
    width: 72px;
    height: 3px;
    background: rgba(255,255,255,0.2);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
  }
  #size-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 13px; height: 13px;
    background: #fff;
    border-radius: 50%;
    cursor: pointer;
  }

  #sidebar {
    position: fixed;
    top: 0; right: 0;
    width: 260px;
    height: 100vh;
    background: rgba(10,10,10,0.92);
    border-left: 1px solid rgba(255,255,255,0.08);
    backdrop-filter: blur(16px);
    z-index: 200;
    display: flex;
    flex-direction: column;
    transform: translateX(100%);
    transition: transform 0.25s ease;
  }
  #sidebar.open { transform: translateX(0); }

  #sidebar-header {
    padding: 20px 18px 12px;
    border-bottom: 1px solid rgba(255,255,255,0.07);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  #sidebar-header span {
    color: rgba(255,255,255,0.5);
    font-size: 10px;
    letter-spacing: 0.15em;
    text-transform: uppercase;
  }
  #btn-close-sidebar {
    background: none; border: none; color: rgba(255,255,255,0.3);
    cursor: pointer; font-size: 18px; line-height: 1;
    transition: color 0.15s;
  }
  #btn-close-sidebar:hover { color: #fff; }

  #save-row {
    display: flex;
    gap: 8px;
    padding: 14px 18px;
    border-bottom: 1px solid rgba(255,255,255,0.07);
  }
  #save-name {
    flex: 1;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 6px;
    color: #fff;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    padding: 6px 10px;
    outline: none;
  }
  #save-name::placeholder { color: rgba(255,255,255,0.2); }
  #save-name:focus { border-color: rgba(255,255,255,0.3); }
  #btn-save {
    background: #fff;
    border: none;
    border-radius: 6px;
    color: #000;
    font-family: 'Courier New', monospace;
    font-size: 11px;
    padding: 6px 12px;
    cursor: pointer;
    font-weight: bold;
    transition: opacity 0.15s;
    white-space: nowrap;
  }
  #btn-save:hover { opacity: 0.8; }

  #drawings-list {
    flex: 1;
    overflow-y: auto;
    padding: 10px 18px;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  #drawings-list::-webkit-scrollbar { width: 4px; }
  #drawings-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

  .drawing-entry {
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 8px;
    padding: 10px 12px;
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    transition: background 0.15s, border-color 0.15s;
  }
  .drawing-entry:hover { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.2); }
  .drawing-entry.current { border-color: rgba(255,255,255,0.4); background: rgba(255,255,255,0.07); }
  .drawing-entry-name {
    flex: 1;
    color: rgba(255,255,255,0.8);
    font-size: 12px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .drawing-entry-meta {
    color: rgba(255,255,255,0.25);
    font-size: 10px;
    white-space: nowrap;
  }
  .drawing-entry-del {
    background: none;
    border: none;
    color: rgba(255,255,255,0.2);
    cursor: pointer;
    font-size: 14px;
    line-height: 1;
    padding: 2px;
    transition: color 0.15s;
    flex-shrink: 0;
  }
  .drawing-entry-del:hover { color: #ff5555; }

  .empty-state {
    color: rgba(255,255,255,0.2);
    font-size: 11px;
    text-align: center;
    padding: 30px 0;
  }

  #zoom-indicator {
    position: fixed;
    top: 20px; right: 24px;
    color: rgba(255,255,255,0.25);
    font-size: 11px;
    letter-spacing: 0.1em;
    z-index: 100;
    pointer-events: none;
    transition: right 0.25s ease;
  }
  body.sidebar-open #zoom-indicator { right: 284px; }

  .hint-mobile { display: none; }
  @media (hover: none) and (pointer: coarse) {
    .hint-desktop { display: none; }
    .hint-mobile { display: inline; }
  }
  #hint {
    position: fixed;
    top: 20px; left: 24px;
    color: rgba(255,255,255,0.2);
    font-size: 11px;
    letter-spacing: 0.08em;
    z-index: 100;
    pointer-events: none;
    line-height: 1.8;
  }

  #current-drawing-name {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: rgba(255,255,255,0.2);
    font-size: 11px;
    letter-spacing: 0.1em;
    z-index: 100;
    pointer-events: none;
  }

  #toast {
    position: fixed;
    bottom: 90px;
    left: 50%;
    transform: translateX(-50%) translateY(10px);
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.8);
    font-size: 11px;
    padding: 7px 16px;
    border-radius: 20px;
    opacity: 0;
    transition: opacity 0.2s, transform 0.2s;
    pointer-events: none;
    z-index: 300;
    letter-spacing: 0.05em;
  }
  #toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div id="zoom-indicator">100%</div>
<div id="hint">
  <span class="hint-desktop">right click + drag to move around<br>ctrl+z undo Â· ctrl+y redo</span>
  <span class="hint-mobile">draw with 1 finger<br>2 fingers to move &amp; zoom</span>
</div>
<div id="current-drawing-name"></div>
<div id="toast"></div>

<div id="sidebar">
  <div id="sidebar-header">
    <span>Saved Drawings</span>
    <button id="btn-close-sidebar">âœ•</button>
  </div>
  <div id="save-row">
    <input id="save-name" type="text" placeholder="Drawing nameâ€¦" maxlength="40">
    <button id="btn-save">Save</button>
  </div>
  <div id="drawings-list"></div>
</div>

<div id="ui">
  <button class="tool-btn active" id="btn-pen" title="Pen (P)">
    <svg data-slot="icon" fill="none" stroke-width="1.5" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L6.832 19.82a4.5 4.5 0 0 1-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 0 1 1.13-1.897L16.863 4.487Zm0 0L19.5 7.125"></path>
    </svg>
  </button>
  <button class="tool-btn" id="btn-erase" title="Eraser (E)">
    <svg data-slot="icon" fill="none" stroke-width="1.5" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path stroke-linecap="round" stroke-linejoin="round" d="M12 9.75 14.25 12m0 0 2.25 2.25M14.25 12l2.25-2.25M14.25 12 12 14.25m-2.58 4.92-6.374-6.375a1.125 1.125 0 0 1 0-1.59L9.42 4.83c.21-.211.497-.33.795-.33H19.5a2.25 2.25 0 0 1 2.25 2.25v10.5a2.25 2.25 0 0 1-2.25 2.25h-9.284c-.298 0-.585-.119-.795-.33Z"></path>
    </svg>
  </button>
  <label id="color-btn" title="Pen color" style="position:relative;width:36px;height:36px;border-radius:50%;border:1px solid rgba(255,255,255,0.2);cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0;overflow:hidden;">
    <span id="color-swatch" style="width:18px;height:18px;border-radius:50%;background:#56cae1;pointer-events:none;"></span>
    <input type="color" id="color-picker" value="#56cae1" style="position:absolute;opacity:0;width:100%;height:100%;cursor:pointer;top:0;left:0;">
  </label>
  <div class="divider"></div>
  <input type="range" id="size-slider" min="1" max="60" value="4">
  <div class="divider"></div>
  <button class="tool-btn" id="btn-undo" title="Undo (Ctrl+Z)" disabled>
    <svg data-slot="icon" fill="none" stroke-width="1.5" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path stroke-linecap="round" stroke-linejoin="round" d="M9 15 3 9m0 0 6-6M3 9h12a6 6 0 0 1 0 12h-3"></path>
    </svg>
  </button>
  <button class="tool-btn" id="btn-redo" title="Redo (Ctrl+Y)" disabled>
    <svg data-slot="icon" fill="none" stroke-width="1.5" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path stroke-linecap="round" stroke-linejoin="round" d="m15 15 6-6m0 0-6-6m6 6H9a6 6 0 0 0 0 12h3"></path>
    </svg>
  </button>
  <div class="divider"></div>
  <button class="tool-btn" id="btn-clear" title="Clear canvas">
    <svg data-slot="icon" fill="none" stroke-width="1.5" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12"></path>
    </svg>
  </button>
  <div class="divider"></div>
  <button class="tool-btn" id="btn-download" title="Download as SVG">
    <svg data-slot="icon" fill="none" stroke-width="1.5" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m.75 12 3 3m0 0 3-3m-3 3v-6m-1.5-9H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z"></path>
    </svg>
  </button>
  <div class="divider"></div>
  <button class="tool-btn" id="btn-library" title="Saved drawings">
    <svg data-slot="icon" fill="none" stroke-width="1.5" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 5.25h16.5m-16.5 4.5h16.5m-16.5 4.5h16.5m-16.5 4.5h16.5"></path>
    </svg>
  </button>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// â”€â”€ Viewport â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let vpX = 0, vpY = 0, vpScale = 1;

// â”€â”€ Drawing state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let tool = 'pen';
let brushSize = 4;
let penColor = '#56cae1';
let isDrawing = false;

// Minimum screen-space stroke width â€” strokes never appear thinner than this
// no matter how far you zoom out
const MIN_SCREEN_WIDTH = 1.0;

// â”€â”€ Undo / redo stacks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let strokes = [];
let redoStack = [];
let currentStroke = null;

// â”€â”€ Session tracking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let currentDrawingKey = null;
let currentDrawingName = '';

// â”€â”€ Pan state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let isPanning = false;
let panStart = null;
let vpAtPanStart = null;
let spaceDown = false;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Rendering
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  render();
}

function screenToWorld(sx, sy) {
  return { x: sx / vpScale + vpX, y: sy / vpScale + vpY };
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.scale(vpScale, vpScale);
  ctx.translate(-vpX, -vpY);
  for (const s of strokes) drawStroke(s);
  if (currentStroke?.pts.length) drawStroke(currentStroke);
  ctx.restore();
}

function drawStroke(stroke) {
  const pts = stroke.pts;
  if (!pts.length) return;
  ctx.save();
  if (stroke.erase) {
    ctx.globalCompositeOperation = 'destination-out';
    ctx.strokeStyle = 'rgba(0,0,0,1)';
  } else {
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = stroke.color || '#56cae1';
  }
  // Enforce minimum screen-space width:
  // stroke.size is in world units; divide by vpScale to get screen pixels.
  // If that's below MIN_SCREEN_WIDTH, use MIN_SCREEN_WIDTH / vpScale instead.
  ctx.lineWidth = Math.max(stroke.size, MIN_SCREEN_WIDTH / vpScale);
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for (let i = 1; i < pts.length; i++) {
    if (i < pts.length - 1) {
      const mx = (pts[i].x + pts[i+1].x) / 2;
      const my = (pts[i].y + pts[i+1].y) / 2;
      ctx.quadraticCurveTo(pts[i].x, pts[i].y, mx, my);
    } else {
      ctx.lineTo(pts[i].x, pts[i].y);
    }
  }
  ctx.stroke();
  ctx.restore();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Undo / Redo
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function pushStroke(stroke) {
  strokes.push(stroke);
  redoStack = [];
  updateUndoButtons();
}

function undo() {
  if (!strokes.length) return;
  redoStack.push(strokes.pop());
  updateUndoButtons();
  render();
}

function redo() {
  if (!redoStack.length) return;
  strokes.push(redoStack.pop());
  updateUndoButtons();
  render();
}

function updateUndoButtons() {
  document.getElementById('btn-undo').disabled = strokes.length === 0;
  document.getElementById('btn-redo').disabled = redoStack.length === 0;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// localStorage helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const LS_INDEX = 'infiniteCanvas_index';

function getIndex() {
  try { return JSON.parse(localStorage.getItem(LS_INDEX)) || []; }
  catch { return []; }
}
function setIndex(arr) {
  localStorage.setItem(LS_INDEX, JSON.stringify(arr));
}

function saveDrawing(name) {
  const key = currentDrawingKey || ('infiniteCanvas_drawing_' + Date.now());
  const data = { strokes, viewport: { vpX, vpY, vpScale }, name, savedAt: Date.now() };
  try {
    localStorage.setItem(key, JSON.stringify(data));
  } catch(e) {
    showToast('Storage full â€” try clearing old drawings');
    return;
  }
  let idx = getIndex();
  const existing = idx.findIndex(e => e.key === key);
  const entry = { key, name, savedAt: data.savedAt };
  if (existing >= 0) idx[existing] = entry;
  else idx.unshift(entry);
  setIndex(idx);
  currentDrawingKey = key;
  currentDrawingName = name;
  document.getElementById('current-drawing-name').textContent = name;
  renderSidebar();
  showToast('Saved "' + name + '"');
}

function loadDrawing(key) {
  try {
    const raw = localStorage.getItem(key);
    if (!raw) { showToast('Drawing not found'); return; }
    const data = JSON.parse(raw);
    strokes = data.strokes || [];
    redoStack = [];
    if (data.viewport) {
      vpX = data.viewport.vpX; vpY = data.viewport.vpY; vpScale = data.viewport.vpScale;
      document.getElementById('zoom-indicator').textContent = Math.round(vpScale * 100) + '%';
    }
    currentDrawingKey = key;
    currentDrawingName = data.name || '';
    document.getElementById('current-drawing-name').textContent = currentDrawingName;
    document.getElementById('save-name').value = currentDrawingName;
    updateUndoButtons();
    render();
    closeSidebar();
    showToast('Loaded "' + currentDrawingName + '"');
  } catch(e) {
    showToast('Failed to load drawing');
  }
}

function deleteDrawing(key) {
  localStorage.removeItem(key);
  let idx = getIndex().filter(e => e.key !== key);
  setIndex(idx);
  if (currentDrawingKey === key) {
    currentDrawingKey = null;
    currentDrawingName = '';
    document.getElementById('current-drawing-name').textContent = '';
  }
  renderSidebar();
  showToast('Deleted');
}

function renderSidebar() {
  const list = document.getElementById('drawings-list');
  const idx = getIndex();
  if (!idx.length) {
    list.innerHTML = '<div class="empty-state">No saved drawings yet</div>';
    return;
  }
  list.innerHTML = '';
  for (const entry of idx) {
    const div = document.createElement('div');
    div.className = 'drawing-entry' + (entry.key === currentDrawingKey ? ' current' : '');
    div.innerHTML = `
      <span class="drawing-entry-name">${escHtml(entry.name)}</span>
      <span class="drawing-entry-meta">${fmtDate(entry.savedAt)}</span>
      <button class="drawing-entry-del" title="Delete">âœ•</button>
    `;
    div.querySelector('.drawing-entry-del').addEventListener('click', ev => {
      ev.stopPropagation();
      if (confirm('Delete "' + entry.name + '"?')) deleteDrawing(entry.key);
    });
    div.addEventListener('click', () => loadDrawing(entry.key));
    list.appendChild(div);
  }
}

function escHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}
function fmtDate(ts) {
  const d = new Date(ts);
  return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
}

function openSidebar() {
  document.getElementById('sidebar').classList.add('open');
  document.body.classList.add('sidebar-open');
  renderSidebar();
}
function closeSidebar() {
  document.getElementById('sidebar').classList.remove('open');
  document.body.classList.remove('sidebar-open');
}

let toastTimer = null;
function showToast(msg) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.classList.add('show');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => el.classList.remove('show'), 2000);
}

function getPos(e) {
  const r = canvas.getBoundingClientRect();
  if (e.touches) return { x: e.touches[0].clientX - r.left, y: e.touches[0].clientY - r.top };
  return { x: e.clientX - r.left, y: e.clientY - r.top };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Mouse events
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
canvas.addEventListener('mousedown', e => {
  if (e.button === 1) e.preventDefault();
  if (e.button === 1 || e.button === 2 || (e.button === 0 && spaceDown)) {
    isPanning = true;
    panStart = { x: e.clientX, y: e.clientY };
    vpAtPanStart = { x: vpX, y: vpY };
    canvas.style.cursor = 'grab';
    return;
  }
  if (e.button !== 0) return;
  const wp = screenToWorld(...Object.values(getPos(e)));
  isDrawing = true;
  currentStroke = { pts: [wp], size: brushSize, color: penColor, erase: tool === 'erase' };
  render();
});

canvas.addEventListener('mousemove', e => {
  if (isPanning) {
    vpX = vpAtPanStart.x - (e.clientX - panStart.x) / vpScale;
    vpY = vpAtPanStart.y - (e.clientY - panStart.y) / vpScale;
    render(); return;
  }
  if (!isDrawing) return;
  const wp = screenToWorld(...Object.values(getPos(e)));
  currentStroke.pts.push(wp);
  render();
});

function finishDraw() {
  if (!isDrawing) return;
  isDrawing = false;
  if (currentStroke?.pts.length) pushStroke(currentStroke);
  currentStroke = null;
  render();
}
function finishPan() {
  if (!isPanning) return;
  isPanning = false;
  if (spaceDown) { canvas.style.cursor = 'grab'; } else { updateCursor(); }
}

canvas.addEventListener('mouseup', e => {
  if (e.button === 1) e.preventDefault();
  finishPan(); finishDraw();
});
canvas.addEventListener('mouseleave', () => { finishDraw(); });
canvas.addEventListener('contextmenu', e => e.preventDefault());

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const before = screenToWorld(e.clientX, e.clientY);
  const factor = e.deltaY < 0 ? 1.1 : 0.9;
  vpScale = Math.max(0.02, Math.min(50, vpScale * factor));
  vpX = before.x - e.clientX / vpScale;
  vpY = before.y - e.clientY / vpScale;
  document.getElementById('zoom-indicator').textContent = Math.round(vpScale * 100) + '%';
  render();
}, { passive: false });

window.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT') return;
  if (e.code === 'Space') { spaceDown = true; canvas.style.cursor = 'grab'; e.preventDefault(); return; }
  if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); return; }
  if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'z'))) { e.preventDefault(); redo(); return; }
  if (e.key === 'p' || e.key === 'P') setTool('pen');
  if (e.key === 'e' || e.key === 'E') setTool('erase');
  if ((e.ctrlKey || e.metaKey) && e.key === 's') { e.preventDefault(); trySave(); }
});
window.addEventListener('keyup', e => {
  if (e.code === 'Space') { spaceDown = false; updateCursor(); }
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Touch â€” Google Maps style
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let touch2 = null;
let momentum = null;

function stopMomentum() {
  if (momentum) { cancelAnimationFrame(momentum.rafId); momentum = null; }
}

function startMomentum(vx, vy) {
  stopMomentum();
  const tick = () => {
    vx *= 0.91; vy *= 0.91;
    if (Math.abs(vx) < 0.08 && Math.abs(vy) < 0.08) { momentum = null; return; }
    vpX -= vx / vpScale;
    vpY -= vy / vpScale;
    render();
    momentum.rafId = requestAnimationFrame(tick);
  };
  momentum = { vx, vy, rafId: requestAnimationFrame(tick) };
}

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  stopMomentum();
  if (e.touches.length >= 2) {
    if (isDrawing) { isDrawing = false; currentStroke = null; render(); }
    const t0 = e.touches[0], t1 = e.touches[1];
    touch2 = {
      midX: (t0.clientX + t1.clientX) / 2,
      midY: (t0.clientY + t1.clientY) / 2,
      dist: Math.hypot(t0.clientX - t1.clientX, t0.clientY - t1.clientY),
      _vx: 0, _vy: 0,
    };
    return;
  }
  touch2 = null;
  const wp = screenToWorld(...Object.values(getPos(e)));
  isDrawing = true;
  currentStroke = { pts: [wp], size: brushSize, color: penColor, erase: tool === 'erase' };
  render();
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (e.touches.length >= 2) {
    const t0 = e.touches[0], t1 = e.touches[1];
    const midX = (t0.clientX + t1.clientX) / 2;
    const midY = (t0.clientY + t1.clientY) / 2;
    const dist = Math.hypot(t0.clientX - t1.clientX, t0.clientY - t1.clientY);
    if (touch2) {
      const worldMid = screenToWorld(midX, midY);
      vpScale = Math.max(0.02, Math.min(50, vpScale * (dist / touch2.dist)));
      vpX = worldMid.x - midX / vpScale;
      vpY = worldMid.y - midY / vpScale;
      vpX -= (midX - touch2.midX) / vpScale;
      vpY -= (midY - touch2.midY) / vpScale;
      touch2._vx = midX - touch2.midX;
      touch2._vy = midY - touch2.midY;
      document.getElementById('zoom-indicator').textContent = Math.round(vpScale * 100) + '%';
      render();
    }
    touch2 = { midX, midY, dist, _vx: touch2?._vx ?? 0, _vy: touch2?._vy ?? 0 };
    return;
  }
  if (!isDrawing) return;
  const wp = screenToWorld(...Object.values(getPos(e)));
  currentStroke.pts.push(wp);
  render();
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  if (touch2 && e.touches.length < 2) {
    const vx = touch2._vx || 0;
    const vy = touch2._vy || 0;
    touch2 = null;
    if (Math.hypot(vx, vy) > 0.5) startMomentum(vx, vy);
    return;
  }
  touch2 = null;
  finishDraw();
}, { passive: false });

canvas.addEventListener('touchcancel', e => {
  touch2 = null;
  stopMomentum();
  finishDraw();
}, { passive: false });

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UI wiring
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setTool(t) {
  tool = t;
  document.getElementById('btn-pen').classList.toggle('active', t === 'pen');
  document.getElementById('btn-erase').classList.toggle('active', t === 'erase');
  // Dim color button when eraser is active
  document.getElementById('color-btn').style.opacity = t === 'erase' ? '0.35' : '1';
  updateCursor();
}

function makeEraserCursor(size) {
  // Draw a circle cursor sized to the current brush on a canvas, return as data URL
  const screenSize = Math.max(size * vpScale, 8);
  const dim = Math.ceil(screenSize) + 4;
  const c = document.createElement('canvas');
  c.width = dim; c.height = dim;
  const cx = dim / 2, cy = dim / 2, r = screenSize / 2;
  const dc = c.getContext('2d');
  dc.beginPath();
  dc.arc(cx, cy, r, 0, Math.PI * 2);
  dc.strokeStyle = 'rgba(255,255,255,0.9)';
  dc.lineWidth = 1.5;
  dc.stroke();
  // small crosshair dot in center
  dc.beginPath();
  dc.arc(cx, cy, 1.5, 0, Math.PI * 2);
  dc.fillStyle = 'rgba(255,255,255,0.7)';
  dc.fill();
  const hotspot = Math.floor(dim / 2);
  return `url(${c.toDataURL()}) ${hotspot} ${hotspot}, crosshair`;
}

function updateCursor() {
  if (isPanning) return;
  if (tool === 'erase') {
    canvas.style.cursor = makeEraserCursor(brushSize);
  } else {
    canvas.style.cursor = 'crosshair';
  }
}

function trySave() {
  const nameInput = document.getElementById('save-name');
  const name = nameInput.value.trim() || currentDrawingName || ('Drawing ' + new Date().toLocaleTimeString());
  nameInput.value = name;
  if (currentDrawingKey && name !== currentDrawingName) currentDrawingKey = null;
  saveDrawing(name);
}

document.getElementById('color-picker').addEventListener('input', e => {
  penColor = e.target.value;
  document.getElementById('color-swatch').style.background = penColor;
  setTool('pen'); // switch back to pen when color picked
});
document.getElementById('btn-pen').addEventListener('click', () => setTool('pen'));
document.getElementById('btn-erase').addEventListener('click', () => setTool('erase'));
document.getElementById('btn-undo').addEventListener('click', undo);
document.getElementById('btn-redo').addEventListener('click', redo);
document.getElementById('btn-clear').addEventListener('click', () => {
  if (!strokes.length) return;
  redoStack.push(...[...strokes].reverse());
  strokes = [];
  updateUndoButtons();
  render();
  showToast('Canvas cleared');
});
document.getElementById('btn-library').addEventListener('click', () => {
  document.getElementById('sidebar').classList.contains('open') ? closeSidebar() : openSidebar();
});
document.getElementById('btn-close-sidebar').addEventListener('click', closeSidebar);
document.getElementById('btn-save').addEventListener('click', trySave);
document.getElementById('save-name').addEventListener('keydown', e => {
  if (e.key === 'Enter') trySave();
});
document.getElementById('size-slider').addEventListener('input', e => {
  brushSize = parseInt(e.target.value);
  updateCursor();
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SVG Export
// Converts all non-erased strokes to SVG paths.
// Eraser strokes are handled via SVG clipPath masking so the result
// looks identical to the canvas render.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('btn-download').addEventListener('click', () => {
  if (!strokes.length) { showToast('Nothing to export'); return; }

  // Compute bounding box of all (non-erase) stroke points
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const s of strokes) {
    if (s.erase) continue;
    for (const p of s.pts) {
      if (p.x < minX) minX = p.x;
      if (p.y < minY) minY = p.y;
      if (p.x > maxX) maxX = p.x;
      if (p.y > maxY) maxY = p.y;
    }
  }
  if (minX === Infinity) { showToast('Nothing to export'); return; }

  // Add padding equal to the largest stroke size
  const maxSize = strokes.reduce((m, s) => Math.max(m, s.size), 0);
  const pad = maxSize;
  minX -= pad; minY -= pad; maxX += pad; maxY += pad;
  const W = maxX - minX;
  const H = maxY - minY;

  // Build SVG path "d" from stroke points using quadratic bezier
  function strokeToPath(pts) {
    if (!pts.length) return '';
    let d = `M ${(pts[0].x - minX).toFixed(2)} ${(pts[0].y - minY).toFixed(2)}`;
    for (let i = 1; i < pts.length; i++) {
      if (i < pts.length - 1) {
        const mx = ((pts[i].x + pts[i+1].x) / 2 - minX).toFixed(2);
        const my = ((pts[i].y + pts[i+1].y) / 2 - minY).toFixed(2);
        const cx = (pts[i].x - minX).toFixed(2);
        const cy = (pts[i].y - minY).toFixed(2);
        d += ` Q ${cx} ${cy} ${mx} ${my}`;
      } else {
        d += ` L ${(pts[i].x - minX).toFixed(2)} ${(pts[i].y - minY).toFixed(2)}`;
      }
    }
    return d;
  }

  // Each draw stroke gets its own clipPath that subtracts all subsequent erase strokes
  // Simple approach: render draw strokes, then cover erased areas with black (background colour)
  // We use a <mask> per draw stroke that clips out all erase strokes that came after it.
  let defs = '';
  let paths = '';

  strokes.forEach((s, i) => {
    if (s.erase) return; // handled via masking below

    // Find all erase strokes that came after this draw stroke
    const eraseAfter = strokes.slice(i + 1).filter(e => e.erase);

    if (eraseAfter.length > 0) {
      const maskId = `m${i}`;
      // Mask: white = show, black = hide
      let erasePaths = eraseAfter.map(es =>
        `<path d="${strokeToPath(es.pts)}" stroke="black" stroke-width="${es.size}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>`
      ).join('');
      defs += `<mask id="${maskId}">
        <rect width="${W.toFixed(2)}" height="${H.toFixed(2)}" fill="white"/>
        ${erasePaths}
      </mask>`;
      paths += `<path d="${strokeToPath(s.pts)}" stroke="${s.color || 'white'}" stroke-width="${s.size}" stroke-linecap="round" stroke-linejoin="round" fill="none" mask="url(#${maskId})"/>`;
    } else {
      paths += `<path d="${strokeToPath(s.pts)}" stroke="${s.color || 'white'}" stroke-width="${s.size}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>`;
    }
  });

  const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${W.toFixed(2)}" height="${H.toFixed(2)}" viewBox="0 0 ${W.toFixed(2)} ${H.toFixed(2)}">
  <defs>${defs}</defs>
  <rect width="${W.toFixed(2)}" height="${H.toFixed(2)}" fill="black"/>
  ${paths}
</svg>`;

  const blob = new Blob([svg], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.download = (currentDrawingName || 'drawing') + '.svg';
  link.href = url;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  showToast('Downloaded SVG');
});

window.addEventListener('resize', resize);
resize();
updateUndoButtons();
</script>
<div id="update-banner" style="
  display:none;
  position:fixed;
  top:16px;left:50%;transform:translateX(-50%);
  background:rgba(255,255,255,0.1);
  border:1px solid rgba(255,255,255,0.25);
  backdrop-filter:blur(12px);
  color:#fff;font-family:'Courier New',monospace;font-size:12px;
  padding:10px 18px;border-radius:24px;
  z-index:500;display:none;align-items:center;gap:12px;white-space:nowrap;
">
  <span>ðŸ”„ New version available</span>
  <button id="btn-update" style="background:#fff;color:#000;border:none;border-radius:12px;padding:4px 12px;font-family:'Courier New',monospace;font-size:11px;font-weight:bold;cursor:pointer;">Reload</button>
  <button id="btn-dismiss-update" style="background:none;border:none;color:rgba(255,255,255,0.4);cursor:pointer;font-size:16px;line-height:1;">âœ•</button>
</div>

<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('sw.js').then(reg => {
      // Check for updates every 60 seconds
      setInterval(() => reg.update(), 60000);

      const showBanner = () => {
        const banner = document.getElementById('update-banner');
        banner.style.display = 'flex';
      };

      // New SW waiting immediately on first load
      if (reg.waiting) { showBanner(); }

      // New SW found after update check
      reg.addEventListener('updatefound', () => {
        const newWorker = reg.installing;
        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            showBanner();
          }
        });
      });

      // Reload once the new SW has taken control
      let refreshing = false;
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        if (!refreshing) { refreshing = true; window.location.reload(); }
      });

      document.getElementById('btn-update').addEventListener('click', () => {
        if (reg.waiting) reg.waiting.postMessage({ type: 'SKIP_WAITING' });
      });
      document.getElementById('btn-dismiss-update').addEventListener('click', () => {
        document.getElementById('update-banner').style.display = 'none';
      });
    }).catch(e => console.log('SW failed', e));
  });
}
</script>
</body>
</html>
